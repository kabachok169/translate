# Глава 33. Boost.Interprocess #

Содержание:

[Совместно-используемая память](#Совместно-используемая-память)  
[Управление совместно-используемой памятью]()  
Синхронизация

Interprocess-связи описывают механизмы для обмена данными между программами, работающими на одном и том же компьютере. Это не 
включает в себя сетевую связь. Для обмена данными между программами, работающими на разных компьютерах, подключенных через сеть, 
смотрите [Главу 32](https://theboostcpplibraries.com/boost.asio "Глава 32. Boost.Asio"), которая описывает Boost.Asio.

В этой главе представлена библиотека [Boost.Interprocess](http://www.boost.org/doc/libs/1_62_0/doc/html/interprocess.html), которая содержит многочисленные классы(, абстрактные)? специальные интерфейсы
операционной системы для межпоцессного взаимодействия. Даже несмотря на то, что концепции межпроцессного взаимодействия одинаковы 
между разными операционными системами, интерфейсы могут сильно различаться. Boost.Interprocess обеспечивает независимый от платформы доступ.

В то время, как Boost.Asio может использоваться для обмена данными между процессами, проходящими на одном компьютере, Boost.Interprocess 
обычно обеспечивает более высокую производительность. Boost.Interprocess-вызовы функций операционной системы оптимизированы для обмена данными между процессами, проходящими на одном компьютере, и, таким образом, должен быть лучшим выбором для обмена данными без сети.

# Совместно-используемая память #

Общая память, как правило, самая быстрая форма межпроцессного взаимодействия. Это обеспечивает область памяти, которая разделяется 
между процессами. Один процесс может записывать данные в этой области, а другой процесс может читать его.

В Boost.Interprocess класс `boost::interprocess::shared_memory_object` используется для представления общей памяти. Включите в проект 
заголовочный файл `boost/interprocess/shared_memory_object.hpp` для использования этого класса.

#### Пример 33.1. Создание общей памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  std::cout << shdmem.get_name() << '\n';
  offset_t size;
  if (shdmem.get_size(size))
    std::cout << size << '\n';
}
```


Конструктор `boost::interprocess::shared_memory_object` принимает три параметра. Первый параметр определяет, должна ли быть создана общая память или открыта. [Пример 33.1](#Пример-331-Создание-общей-памяти) 
обрабатывает оба варианта. `boost::interprocess::open_or_create` откроет общую память, если она уже существует или создаст ее в обратном  случае. 

Открытие существующей общей памяти предполагает, что она была создана ранее. Для того, чтобы однозначно определить совместно-используемую  память, ей присваивается имя. Это имя передается вторым параметром в конструктор `boost::interprocess::shared_memory_object`

Третий параметр определяет, каким образом процесс может получить доступ к памяти. В [Примере 33.1](#Пример-331-Создание-общей-памяти) 
`boost::interprocess::read_write` показывает, что процесс имеет доступ к чтению и записи.

После создания объекта типа `boost::interprocess::shared_memory_object`, соответствующий общий блок памяти будет существовать внутри операционной системы. Изначально размер этой памяти 0. Чтобы использовать эту область, вызовите `truncate()`, передав размер памяти в байтах. В [Примере 33.1](#Пример-331-Создание-общей-памяти) общая память обеспечивает пространство 1024 байта. `truncate()` может быть вызвана только в том случае, если совместная память была открыта с использованием `boost::interprocess::read_write`. В ином случае выбросится исключение с типом `boost::interprocess::interprocess_exception is thrown`. `truncate()` можно вызывать несколько раз, чтобы регулировать размер выделенной памяти.

После создания общей памяти, могут быть вызваны функции-члены, такие как `get_name()` и `get_size()`, для запроса имени или размера этой памяти.

Поскольку совместная память используется для обмена информацией между разными процессами, каждый из них должен отобразить? общую память в свое адресное пространство. Для этого используется класс `boost::interprocess::mapped_region`. Неожиданностью может оказаться то, что для доступа к совместной памяти понадобятся два класса (`boost::interprocess::shared_memory_object` и `boost::interprocess::mapped_region`). Это сделано для того, чтобы класс `boost::interprocess::mapped_region` мог также быть использован для отображения других объектов в адресное пространство процесса.

#### Пример 33.2. Отображение общей памяти в адресное пространство процесса
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  mapped_region region{shdmem, read_write};
  std::cout << std::hex << region.get_address() << '\n';
  std::cout << std::dec << region.get_size() << '\n';
  mapped_region region2{shdmem, read_only};
  std::cout << std::hex << region2.get_address() << '\n';
  std::cout << std::dec << region2.get_size() << '\n';
}
```


Для использования класса `boost::interprocess::mapped_region` подключите заголовочный файл `boost/interprocess/mapped_region.hpp`. В качестве первого параметра конструктора `boost::interprocess::mapped_region` должен быть передан объект типа  `boost::interprocess::shared_memory_object` Второй параметр определяет степень доступа к памяти(read-only или read-write).

[Пример 33.2](#Пример-332-Отображение-общей-памяти-в-адресное-пространство-процесса) создает два объекта типа `boost::interprocess::mapped_region`. Общая память с именем Boost отображается дважды в адресное пространство процесса. Адрес и размер отображенной области памяти записывается в стандартный поток вывода с помощью функций-членов `get_address()` и `get_size()`. `get_size()` возвращает 1024 в обоих случаях, но возвращаемое значение `get_address()` отличается для каждого объекта.

