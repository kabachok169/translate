# Глава 33. Boost.Interprocess #

Содержание:

[Совместно-используемая память](#Совместно-используемая-память)  
[Управление совместно-используемой памятью]()  
Синхронизация

Interprocess описывает механизмы для обмена данными между программами, работающими на одном и том же компьютере. Не 
включает в себя сетевую связь. Для обмена данными между программами в одной сети, смотрите [Главу 32](https://theboostcpplibraries.com/boost.asio "Глава 32. Boost.Asio"), которая описывает Boost.Asio.

В этой главе представлена библиотека [Boost.Interprocess](http://www.boost.org/doc/libs/1_62_0/doc/html/interprocess.html), которая содержит многочисленные классы, которые абстрагируют специальные интерфейсы операционной системы для межпроцессного взаимодействия. Несмотря на то, что концепции межпроцессного взаимодействия одинаковы среди разных операционных систем, интерфейсы могут сильно различаться. Boost.Interprocess обеспечивает не зависимый от платформы доступ.

Boost.Asio может использоваться для обмена данными между процессами, проходящими на одном компьютере, однако Boost.Interprocess 
обеспечивает более высокую производительность. Boost.Interprocess вызывает функции операционной системы, оптимизированные для обмена данными между процессами, проходящими на одном компьютере. Таким образом, Boost.Interprocess - лучший выбор для обмена данными без сети.

# Совместно используемая память #

Общая память, как правило, самая быстрая форма межпроцессного взаимодействия. Под этим понятием подразумевается область памяти, которая разделяется между процессами. Один процесс может записывать данные в этой области, а другой процесс может читать его.

В Boost.Interprocess класс `boost::interprocess::shared_memory_object` используется для представления общей памяти. Чтобы использовать этот класс необходимо подключить заголовочный файл `boost/interprocess/shared_memory_object.hpp`.

#### Пример 33.1. Создание общей памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  std::cout << shdmem.get_name() << '\n';
  offset_t size;
  if (shdmem.get_size(size))
    std::cout << size << '\n';
}
```


Конструктор `boost::interprocess::shared_memory_object` принимает три параметра. Первый параметр определяет открытие или создание общей памяти. В [Примере 33.1](#Пример-331-Создание-общей-памяти) 
рассмотрены оба варианта: `boost::interprocess::open_or_create` откроет общую память, если она уже существует или создаст ее в ином  случае. 

Открытие существующей совместной памяти предполагает, что она была создана ранее. Для того, чтобы однозначно определить совместно-используемую  память, ей присваивается имя, которое передается вторым параметром в конструктор `boost::interprocess::shared_memory_object`.

Третий параметр определяет, каким образом процесс может получить доступ к памяти. В [Примере 33.1](#Пример-331-Создание-общей-памяти) 
`boost::interprocess::read_write` показывает, что процесс имеет доступ к чтению и записи.

После создания объекта типа `boost::interprocess::shared_memory_object` соответствующий общий блок памяти будет существовать внутри операционной системы. Изначально размер этой памяти 0. Чтобы использовать эту область, вызовите `truncate()`, передав размер памяти в байтах. В [Примере 33.1](#Пример-331-Создание-общей-памяти) общая память обеспечивает область, размером 1024 байта. `truncate()` может быть вызвана только в том случае, если совместная память была открыта с использованием `boost::interprocess::read_write`. В ином случае бросается исключение с типом `boost::interprocess::interprocess_exception`. `truncate()` можно вызывать для регулирования размера выделенной памяти.

После создания общей памяти, могут быть вызваны методы, такие как `get_name()` и `get_size()`, для получения имени или размера этой памяти.

Поскольку совместная память используется для обмена информацией между разными процессами, каждый из них должен отобразить? общую память в свое адресное пространство. Для этого используется класс `boost::interprocess::mapped_region`. Неожиданностью может оказаться то, что для доступа к совместной памяти понадобятся два класса (`boost::interprocess::shared_memory_object` и `boost::interprocess::mapped_region`). Это сделано для того, чтобы класс `boost::interprocess::mapped_region` мог также быть использован для отображения других объектов в адресное пространство процесса.

#### Пример 33.2. Отображение общей памяти в адресное пространство процесса
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  mapped_region region{shdmem, read_write};
  std::cout << std::hex << region.get_address() << '\n';
  std::cout << std::dec << region.get_size() << '\n';
  mapped_region region2{shdmem, read_only};
  std::cout << std::hex << region2.get_address() << '\n';
  std::cout << std::dec << region2.get_size() << '\n';
}
```


Для использования класса `boost::interprocess::mapped_region` необъходимо подключить заголовочный файл `boost/interprocess/mapped_region.hpp`. В качестве первого параметра конструктора `boost::interprocess::mapped_region` должен быть передан объект типа  `boost::interprocess::shared_memory_object` Второй параметр определяет степень доступа к памяти (read-only или read-write).

В [Примере 33.2](#Пример-332-Отображение-общей-памяти-в-адресное-пространство-процесса) создается два объекта типа `boost::interprocess::mapped_region`. Общая память с именем Boost отображается дважды в адресное пространство процесса. Адрес и размер отображенной области памяти записываются в стандартный поток вывода с помощью методов `get_address()` и `get_size()`. `get_size()` возвращает 1024 в обоих случаях, но возвращаемое значение `get_address()` отличается для каждого объекта.

####Note

[Пример 33.2](#Пример-332-Отображение-общей-памяти-в-адресное-пространство-процесса) и еще несколько примеров, приведенных ниже вызовут ошибку при компиляции в  Visual C++ 2013 и Boost 1.55.0(исправлена в Boost 1.56.0). Этот баг описан в [тикете 9332](https://svn.boost.org/trac/boost/ticket/9332).

#### Пример 33.3. Запись и чтение числа в общей памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  mapped_region region{shdmem, read_write};
  int *i1 = static_cast<int*>(region.get_address());
  *i1 = 99;
  mapped_region region2{shdmem, read_only};
  int *i2 = static_cast<int*>(region2.get_address());
  std::cout << *i2 << '\n';
}
```
В [Примере 33.3](#Пример-333-Запись-и-чтение-числа-в-общей-памяти) используется отображенная область памяти для записи и чтения числа.  ***region*** записывает число `99` в начало области. ***region2*** читает соответствующее место в этой области и выводит число в стандартный поток вывода. Несмотря на то, что ***region*** и ***region2*** представляют различные области памяти в процессе, как видно в возвращаемом значении `get_address()` в предыдущем примере, программа напечатает `99`, поскольку обе области памяти имеют доступ к одной  совместной памяти.

#### Пример 33.4. Удаление совместно-используемой памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  bool removed = shared_memory_object::remove("Boost");
  std::cout << std::boolalpha << removed << '\n';
}
```
Для удаления общей памяти, в `boost::interprocess::shared_memory_object` есть функция-член `remove()`, принимающая имя этой памяти в качестве параметра (см. [Пример 33.4](#Пример-334-Удаление-совместно-используемой-памяти)).

Boost.Interprocess частично поддерживает идиому RAII через класс `boost::interprocess::remove_shared_memory_on_destroy`. В конструкторе принимается имя существующей памяти, и, если объект этого класса был разрушен, совместная память удаляется (в деструкторе этого объекта).

Конструктор `boost::interprocess::remove_shared_memory_on_destroy` не создает и не открывает общую память. Таким образом он не является типичным представителем RAII.

Если не вызывается `remove()`, совместная память не удаляется, даже при завершении программы. Удаляется память автоматически или нет 
зависит от операционной системы. Windows и большинство Unix операционных систем автоматически удаляю память при перезагрузке.

Windows обеспечивает особый вид совместной памяти, которая автоматически удаляется при завершении последнего процесса, работающего с ней. Чтобы ее использовать, нужно работать с классом `boost::interprocess::windows_shared_memory`, описанным в `boost/interprocess/windows_shared_memory.hpp`(см. [Пример 33.5](#Пример-335-Использование-специальной-совместной-памяти-windows)). 

#### Пример 33.5. Использование специальной совместной памяти Windows
```c++
#include <boost/interprocess/windows_shared_memory.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  windows_shared_memory shdmem{open_or_create, "Boost", read_write, 1024};
  mapped_region region{shdmem, read_write};
  int *i1 = static_cast<int*>(region.get_address());
  *i1 = 99;
  mapped_region region2{shdmem, read_only};
  int *i2 = static_cast<int*>(region2.get_address());
  std::cout << *i2 << '\n';
}
```
В `boost::interprocess::windows_shared_memory` нет функции `truncate()`, вместо этого размер памяти передается в конструктор 4-м параметром.

Несмотря на то, что этот класс может использоваться только на Windows, он полезен, когда данные нужно разделить между процессами, использующими такой же специальный тип памяти.

# Управляемая совместная память

В предыдущем разделе был рассмотрен класс `boost::interprocess::shared_memory_object`, который используют для создания и управления общей памятью. На деле этот класс используется редко, так как для него необходимы программы, читающие и записывающие отдельные байты из и в совместную память. Стиль C++ способствует созданию объектов классов, скрывая специфику, где и как данные хранятся в памяти.

Boost.Interprocess обеспечивает `boost::interprocess::managed_shared_memory` - класс, описанный в `boost/interprocess/managed_shared_memory.hpp`. Он используется для поддержки управляемой совместной памяти. Этот класс позволяет создавать объекты, хранящиеся в общей памяти, что делает эти объекты доступными для любого процесса, имеющего доступ к ней.

#### Пример 33.6. Использование управляемой общей памяти
```c++
#include <boost/interprocess/managed_shared_memory.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object::remove("Boost");
  managed_shared_memory managed_shm{open_or_create, "Boost", 1024};
  int *i = managed_shm.construct<int>("Integer")(99);
  std::cout << *i << '\n';
  std::pair<int*, std::size_t> p = managed_shm.find<int>("Integer");
  if (p.first)
    std::cout << *p.first << '\n';
}
```
[Пример 33.6](#Пример-336-Использование-управляемой-общей-памяти) открывает совместно-используемую память с именем Boost размером 1024 байта. Если ее не существовало, она создастся автоматически.

В обычной общей памяти отдельные байты доступны непосредственно для чтения или записи. Управляемая совместная память использует методы, такие, как `construct()`, которые принимают шаблонные параметры.(В [Примере 33.6](#Пример-336-Использование-управляемой-общей-памяти) - `int`). Метод принимает имя объекта, созданного в общей памяти. [Пример 33.6](#Пример-336-Использование-управляемой-общей-памяти) использует имя Integer.

Поскольку `construct()` возвращает прокси объект, параметры могут передаваться для инициализации созданного объекта. Синтаксис выглядит, как вызов конструктора. Это гарантирует, что объекты могут быть созданы и инициализированы в управляемой общей памяти.

Чтобы получить доступ к конкретному объекту в управляемой совместной памяти используется метод `find()`. Передав имя объекта, который требуется найти в качестве параметра, `find()` возвращает указатель на этот объект или 0, если он не был найден.

Как видно в [Примере 33.6](#Пример-336-Использование-управляемой-общей-памяти), `find()` возвращает объект типа `std::pair`. указатель на объект лежит в **first**. [Пример 33.7](#Пример-337-Создание-массивов-в-совместной-памяти) показывает, что лежит в **second**.

#### Пример 33.7. Создание массивов в совместной памяти
```c++
#include <boost/interprocess/managed_shared_memory.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object::remove("Boost");
  managed_shared_memory managed_shm{open_or_create, "Boost", 1024};
  int *i = managed_shm.construct<int>("Integer")[10](99);
  std::cout << *i << '\n';
  std::pair<int*, std::size_t> p = managed_shm.find<int>("Integer");
  if (p.first)
  {
    std::cout << *p.first << '\n';
    std::cout << p.second << '\n';
  }
}
```
В [Примере 33.7](#Пример-337-Создание-массивов-в-совместной-памяти) массив с десятью элементами типа `int` создается, путем записи в квадратные скобки числа `10` после вызова `construct()`. Это же число выведется в стандартный поток вывода, путем использования переменной **second**. Благодаря этой переменной вы можете узнать, найденные `find()` объекты являются единичными(тогда в **second** будет записана цифра 1) или представляют собой массивы. 

Обратите внимание, что все десять элементов в массиве инициализируются значением 99. Чтобы инициализировать переменные с разными значениями, нужно передать итератор. 

`construct()` не сработает, если объект с данным именем уже существует в управляемой общей памяти. В этом случае `construct()` вернет 0, и инициализации не произойдет. Чтобы использовать существующий объект, используйте метод `find_or_construct()`, который возвращает указатель на существующий объект или создает новый.

#### Пример 33.8. Исключение типа `boost::interprocess::bad_alloc`
```c++
#include <boost/interprocess/managed_shared_memory.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  try
  {
    shared_memory_object::remove("Boost");
    managed_shared_memory managed_shm{open_or_create, "Boost", 1024};
    int *i = managed_shm.construct<int>("Integer")[4096](99);
  }
  catch (boost::interprocess::bad_alloc &ex)
  {
    std::cerr << ex.what() << '\n';
  }
}
```
Есть и другие случаи, при которых `construct()` не сработает. [Пример 33.8](#Пример-338-Исключение-типа-boostinterprocessbad_alloc) пытыется создать массив типа `int` с 4096-ю элементами. Управляемая совместная память при этом вмещает только 1024 байта. Это вызывает исключение типа ` boost::interprocess::bad_alloc`.

После того, как объекты были созданы в управляемой общей памяти, они могут быть разрушены с помощью метода `destroy()`.
