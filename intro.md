# Глава 33. Boost.Interprocess #

Содержание:

[Совместно-используемая память](#Совместно-используемая-память)  
[Управление совместно-используемой памятью](#Управляемая-совместная-память)  
Синхронизация

Interprocess описывает механизмы для обмена данными между программами, работающими на одном и том же компьютере. Не 
включает в себя сетевую связь. Для обмена данными между программами в одной сети, смотрите [Главу 32](https://theboostcpplibraries.com/boost.asio "Глава 32. Boost.Asio"), которая описывает Boost.Asio.

В этой главе представлена библиотека [Boost.Interprocess](http://www.boost.org/doc/libs/1_62_0/doc/html/interprocess.html), которая содержит многочисленные классы, которые абстрагируют специальные интерфейсы операционной системы для межпроцессного взаимодействия. Несмотря на то, что концепции межпроцессного взаимодействия одинаковы среди разных операционных систем, интерфейсы могут сильно различаться. Boost.Interprocess обеспечивает не зависимый от платформы доступ.

Boost.Asio может использоваться для обмена данными между процессами, проходящими на одном компьютере, однако Boost.Interprocess 
обеспечивает более высокую производительность. Boost.Interprocess вызывает функции операционной системы, оптимизированные для обмена данными между процессами, проходящими на одном компьютере. Таким образом, Boost.Interprocess - лучший выбор для обмена данными без сети.

# Совместно используемая память #

Общая память, как правило, самая быстрая форма межпроцессного взаимодействия. Под этим понятием подразумевается область памяти, которая разделяется между процессами. Один процесс может записывать данные в этой области, а другой процесс может читать его.

В Boost.Interprocess класс `boost::interprocess::shared_memory_object` используется для представления общей памяти. Чтобы использовать этот класс необходимо подключить заголовочный файл `boost/interprocess/shared_memory_object.hpp`.

#### Пример 33.1. Создание общей памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  std::cout << shdmem.get_name() << '\n';
  offset_t size;
  if (shdmem.get_size(size))
    std::cout << size << '\n';
}
```


Конструктор `boost::interprocess::shared_memory_object` принимает три параметра. Первый параметр определяет открытие или создание общей памяти. В [Примере 33.1](#Пример-331-Создание-общей-памяти) 
рассмотрены оба варианта: `boost::interprocess::open_or_create` откроет общую память, если она уже существует или создаст ее в ином  случае. 

Открытие существующей совместной памяти предполагает, что она была создана ранее. Для того, чтобы однозначно определить совместно-используемую  память, ей присваивается имя, которое передается вторым параметром в конструктор `boost::interprocess::shared_memory_object`.

Третий параметр определяет, каким образом процесс может получить доступ к памяти. В [Примере 33.1](#Пример-331-Создание-общей-памяти) 
`boost::interprocess::read_write` показывает, что процесс имеет доступ к чтению и записи.

После создания объекта типа `boost::interprocess::shared_memory_object` соответствующий общий блок памяти будет существовать внутри операционной системы. Изначально размер этой памяти 0. Чтобы использовать эту область, вызовите `truncate()`, передав размер памяти в байтах. В [Примере 33.1](#Пример-331-Создание-общей-памяти) общая память обеспечивает область, размером 1024 байта. `truncate()` может быть вызвана только в том случае, если совместная память была открыта с использованием `boost::interprocess::read_write`. В ином случае бросается исключение с типом `boost::interprocess::interprocess_exception`. `truncate()` можно вызывать для регулирования размера выделенной памяти.

После создания общей памяти, могут быть вызваны методы, такие как `get_name()` и `get_size()`, для получения имени или размера этой памяти.

Поскольку совместная память используется для обмена информацией между разными процессами, каждый из них должен отобразить? общую память в свое адресное пространство. Для этого используется класс `boost::interprocess::mapped_region`. Неожиданностью может оказаться то, что для доступа к совместной памяти понадобятся два класса (`boost::interprocess::shared_memory_object` и `boost::interprocess::mapped_region`). Это сделано для того, чтобы класс `boost::interprocess::mapped_region` мог также быть использован для отображения других объектов в адресное пространство процесса.

#### Пример 33.2. Отображение общей памяти в адресное пространство процесса
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  mapped_region region{shdmem, read_write};
  std::cout << std::hex << region.get_address() << '\n';
  std::cout << std::dec << region.get_size() << '\n';
  mapped_region region2{shdmem, read_only};
  std::cout << std::hex << region2.get_address() << '\n';
  std::cout << std::dec << region2.get_size() << '\n';
}
```


Для использования класса `boost::interprocess::mapped_region` необъходимо подключить заголовочный файл `boost/interprocess/mapped_region.hpp`. В качестве первого параметра конструктора `boost::interprocess::mapped_region` должен быть передан объект типа  `boost::interprocess::shared_memory_object` Второй параметр определяет степень доступа к памяти (read-only или read-write).

В [Примере 33.2](#Пример-332-Отображение-общей-памяти-в-адресное-пространство-процесса) создается два объекта типа `boost::interprocess::mapped_region`. Общая память с именем Boost отображается дважды в адресное пространство процесса. Адрес и размер отображенной области памяти записываются в стандартный поток вывода с помощью методов `get_address()` и `get_size()`. `get_size()` возвращает 1024 в обоих случаях, но возвращаемое значение `get_address()` отличается для каждого объекта.

####Note

[Пример 33.2](#Пример-332-Отображение-общей-памяти-в-адресное-пространство-процесса) и еще несколько примеров, приведенных ниже вызовут ошибку при компиляции в  Visual C++ 2013 и Boost 1.55.0(исправлена в Boost 1.56.0). Этот баг описан в [тикете 9332](https://svn.boost.org/trac/boost/ticket/9332).

#### Пример 33.3. Запись и чтение числа в общей памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  mapped_region region{shdmem, read_write};
  int *i1 = static_cast<int*>(region.get_address());
  *i1 = 99;
  mapped_region region2{shdmem, read_only};
  int *i2 = static_cast<int*>(region2.get_address());
  std::cout << *i2 << '\n';
}
```
В [Примере 33.3](#Пример-333-Запись-и-чтение-числа-в-общей-памяти) используется отображенная область памяти для записи и чтения числа.  ***region*** записывает число `99` в начало области. ***region2*** читает соответствующее место в этой области и выводит число в стандартный поток вывода. Несмотря на то, что ***region*** и ***region2*** представляют различные области памяти в процессе, как видно в возвращаемом значении `get_address()` в предыдущем примере, программа напечатает `99`, поскольку обе области памяти имеют доступ к одной  совместной памяти.

#### Пример 33.4. Удаление совместно-используемой памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  bool removed = shared_memory_object::remove("Boost");
  std::cout << std::boolalpha << removed << '\n';
}
```
Для удаления общей памяти, в `boost::interprocess::shared_memory_object` есть функция-член `remove()`, принимающая имя этой памяти в качестве параметра (см. [Пример 33.4](#Пример-334-Удаление-совместно-используемой-памяти)).

Boost.Interprocess частично поддерживает идиому RAII через класс `boost::interprocess::remove_shared_memory_on_destroy`. В конструкторе принимается имя существующей памяти, и, если объект этого класса был разрушен, совместная память удаляется (в деструкторе этого объекта).

Конструктор `boost::interprocess::remove_shared_memory_on_destroy` не создает и не открывает общую память. Таким образом он не является типичным представителем RAII.

Если не вызывается `remove()`, совместная память не удаляется, даже при завершении программы. Удаляется память автоматически или нет 
зависит от операционной системы. Windows и большинство Unix операционных систем автоматически удаляю память при перезагрузке.

Windows обеспечивает особый вид совместной памяти, которая автоматически удаляется при завершении последнего процесса, работающего с ней. Чтобы ее использовать, нужно работать с классом `boost::interprocess::windows_shared_memory`, описанным в `boost/interprocess/windows_shared_memory.hpp`(см. [Пример 33.5](#Пример-335-Использование-специальной-совместной-памяти-windows)). 

#### Пример 33.5. Использование специальной совместной памяти Windows
```c++
#include <boost/interprocess/windows_shared_memory.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  windows_shared_memory shdmem{open_or_create, "Boost", read_write, 1024};
  mapped_region region{shdmem, read_write};
  int *i1 = static_cast<int*>(region.get_address());
  *i1 = 99;
  mapped_region region2{shdmem, read_only};
  int *i2 = static_cast<int*>(region2.get_address());
  std::cout << *i2 << '\n';
}
```
В `boost::interprocess::windows_shared_memory` нет функции `truncate()`, вместо этого размер памяти передается в конструктор 4-м параметром.

Несмотря на то, что этот класс может использоваться только на Windows, он полезен, когда данные нужно разделить между процессами, использующими такой же специальный тип памяти.

# Управляемая совместная память

В предыдущем разделе был рассмотрен класс `boost::interprocess::shared_memory_object`, который используют для создания и управления общей памятью. На деле этот класс используется редко, так как для него необходимы программы, читающие и записывающие отдельные байты из и в совместную память. Стиль C++ способствует созданию объектов классов, скрывая специфику, где и как данные хранятся в памяти.

Boost.Interprocess обеспечивает `boost::interprocess::managed_shared_memory` - класс, описанный в `boost/interprocess/managed_shared_memory.hpp`. Он используется для поддержки управляемой совместной памяти. Этот класс позволяет создавать объекты, хранящиеся в общей памяти, что делает эти объекты доступными для любого процесса, имеющего доступ к ней.

#### Пример 33.6. Использование управляемой общей памяти
```c++
#include <boost/interprocess/managed_shared_memory.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object::remove("Boost");
  managed_shared_memory managed_shm{open_or_create, "Boost", 1024};
  int *i = managed_shm.construct<int>("Integer")(99);
  std::cout << *i << '\n';
  std::pair<int*, std::size_t> p = managed_shm.find<int>("Integer");
  if (p.first)
    std::cout << *p.first << '\n';
}
```
[Пример 33.6](#Пример-336-Использование-управляемой-общей-памяти) открывает совместно-используемую память с именем Boost размером 1024 байта. Если ее не существовало, она создастся автоматически.

В обычной общей памяти отдельные байты доступны непосредственно для чтения или записи. Управляемая совместная память использует методы, такие, как `construct()`, которые принимают шаблонные параметры (в [Примере 33.6](#Пример-336-Использование-управляемой-общей-памяти) - `int`). Метод принимает имя объекта, созданного в общей памяти. [Пример 33.6](#Пример-336-Использование-управляемой-общей-памяти) использует имя Integer.

Поскольку `construct()` возвращает прокси объект, параметры могут передаваться для инициализации созданного объекта. Синтаксис выглядит, как вызов конструктора. Это гарантирует, что объекты могут быть созданы и инициализированы в управляемой общей памяти.

Чтобы получить доступ к конкретному объекту в управляемой совместной памяти используется метод `find()`. После передачи имени объекта, который требуется найти, в качестве параметра, `find()` возвращает указатель на этот объект или 0, если он не был найден.

Как видно в [Примере 33.6](#Пример-336-Использование-управляемой-общей-памяти), `find()` возвращает объект типа `std::pair`. указатель на объект лежит в **first**. [Пример 33.7](#Пример-337-Создание-массивов-в-совместной-памяти) показывает, что лежит в **second**.

#### Пример 33.7. Создание массивов в совместной памяти
```c++
#include <boost/interprocess/managed_shared_memory.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object::remove("Boost");
  managed_shared_memory managed_shm{open_or_create, "Boost", 1024};
  int *i = managed_shm.construct<int>("Integer")[10](99);
  std::cout << *i << '\n';
  std::pair<int*, std::size_t> p = managed_shm.find<int>("Integer");
  if (p.first)
  {
    std::cout << *p.first << '\n';
    std::cout << p.second << '\n';
  }
}
```
В [Примере 33.7](#Пример-337-Создание-массивов-в-совместной-памяти) массив с десятью элементами типа `int` создается, путем записи в квадратные скобки числа `10` после вызова `construct()`. Это же число выведется в стандартный поток вывода, путем использования переменной **second**. Благодаря этой переменной вы можете узнать, найденные `find()` объекты являются единичными (тогда в **second** будет записана цифра 1) или представляют собой массивы. 

Обратите внимание, что все десять элементов в массиве инициализируются значением 99. Чтобы инициализировать переменные с разными значениями, нужно передать итератор. 

`construct()` не сработает, если объект с данным именем уже существует в управляемой общей памяти. В этом случае `construct()` вернет 0, и инициализации не произойдет. Чтобы использовать существующий объект, используйте метод `find_or_construct()`, который возвращает указатель на существующий объект или создает новый.

#### Пример 33.8. Исключение типа `boost::interprocess::bad_alloc`
```c++
#include <boost/interprocess/managed_shared_memory.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  try
  {
    shared_memory_object::remove("Boost");
    managed_shared_memory managed_shm{open_or_create, "Boost", 1024};
    int *i = managed_shm.construct<int>("Integer")[4096](99);
  }
  catch (boost::interprocess::bad_alloc &ex)
  {
    std::cerr << ex.what() << '\n';
  }
}
```
Есть и другие случаи, при которых `construct()` не сработает. [Пример 33.8](#Пример-338-Исключение-типа-boostinterprocessbad_alloc) пытыется создать массив типа `int` с 4096-ю элементами. Управляемая совместная память при этом вмещает только 1024 байта. Это вызывает исключение типа ` boost::interprocess::bad_alloc`.

После того, как объекты были созданы в управляемой общей памяти, они могут быть разрушены с помощью метода `destroy()`.


#### Пример 33.9. Удаление объектов в совместно используемой памяти
```c++
#include <boost/interprocess/managed_shared_memory.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object::remove("Boost");
  managed_shared_memory managed_shm{open_or_create, "Boost", 1024};
  int *i = managed_shm.find_or_construct<int>("Integer")(99);
  std::cout << *i << '\n';
  managed_shm.destroy<int>("Integer");
  std::pair<int*, std::size_t> p = managed_shm.find<int>("Integer");
  std::cout << p.first << '\n';
}
```

В [Примере 33.9](#Пример-339-Удаление-объектов-в-совместно-используемой-памяти), имя объекта, который нужно удалить, передается в качестве единственного параметра в метод `destroy()`. По возвращаемому значению типа `bool` можно проверить, был ли найден данный объект и успешно ли удален. Поскольку объект всегда будет удален, если он найден, возвращаемое значение `false` указывает на то, что ни один объект с указанным именем не был найден.

Метод `destroy_ptr()` может быть использован для передачи указателя на объект в управляемой совместно-используемой памятью. Он также может быть использован для удаления массивов.

Поскольку управляемая совместно-используемая память позволяет достаточно легко обмениваться объектами между процессами, представляется естественным так же использовать и контейнеры из стандартной библиотеки. Тем не менее, эти контейнеры выделяют памят с использованием оператора `new()`. Для того, чтобы использовать эти контейнеры в управляемом совместно используемой памяти, им должно быть указано, что выделение пямяти должно происходить в расшаренной(!) памяти.

Многие реализации стандартной библиотеки не являются достаточно гибкими, чтобы использовать контейнеры, такие как `std::string` или `std::list` с Boost.Interprocess. Это включает в себя реализацию встроенные в Visual C ++ 2013, GCC и Clang.

Для того, чтобы позволить разработчикам использовать контейнеры из стандартной библиотеки, Boost.Interprocess обеспечивает более гибкую реализацию в пространстве имен `boost::interprocess`. Например, `boost::interprocess::string` действует точно так же, как и его аналог `std::string`, за исключением того, что строки могут безопасно храниться в управляемой совместно-используемой памяти [Пример 33.10](#Пример-3310-Размещение-строки-в-общую-память).


#### Пример 33.10. Размещение строки в общую память
```c++
#include <boost/interprocess/managed_shared_memory.hpp>
#include <boost/interprocess/allocators/allocator.hpp>
#include <boost/interprocess/containers/string.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object::remove("Boost");
  managed_shared_memory managed_shm{open_or_create, "Boost", 1024};
  
  typedef allocator<char,
    managed_shared_memory::segment_manager> CharAllocator;
  typedef basic_string<char, std::char_traits<char>, CharAllocator> string_t;
  
  string_t *s = managed_shm.find_or_construct<string_t>("String")("Hello!",
    managed_shm.get_segment_manager());
    
  s->insert(5, ", world");
  std::cout << *s << '\n';
}
```

Чтобы создать строку, которая будет выделять память в той же управляемой совместно используемой памяти, в которой она находится, должен быть определен соответствующий тип. Новый тип-строка должен использовать аллокатор, предоставляемый Boost.Interprocess, вместо аллокатора по умолчанию, предоставляемый стандартом.

Для этой цели Boost.Interprocess обеспечивает класс `boost::interprocess::allocator`, который определен в `boost/interprocess/allocators/allocator.hpp`. С помощью этого класса может быть создаy распределитель памяти, который внутри использует менеджер сегментов управляемой совместно используемой памяти. Менеджер сегментов отвечает за управление памятью в пределах расшаренной(!) памяти блока. С помощью нового созданного аллокатора можно определить соответствующий тип строки. Но опять же, как было указано выше, используйте `boost::interprocess::basic_string` вместо `std::basic_string`. Новый тип (string_t) в [примере 33.10](#Пример-3310-Размещение-строки-в-общую-память) - основан на `boost::interprocess::basic_string` и обращается к менеджеру сегментов через свой распределитель. Чтобы позволить конкретному экземпляру, созданного вызовом `find_or_construct()`, знать, к какому сегмент-менеджеру он должен получить доступ, нужно передать указатель на соответствующий менеджер сегмента в качестве второго параметра конструктора.

Boost.Interprocess предоставляет реализации для многих других контейнеров из стандартной библиотеки. Например, `boost::interprocess::vector` и `boost::interprocess::map` определены в `boost/interprocess/containers/vector.hpp`  и `boost/interprocess/containers/map.hpp` соответственно.

Пожалуйста, обратите внимание, что контейнеры из **Boost.Container** поддерживают **Boost.Interprocess** и могут быть введены в общую память. Они могут быть использованы вместо контейнеров от boost::interprocess. Boost.Container вводится в [Главе 20](#https://theboostcpplibraries.com/boost.container).

Всякий раз, когда управляемая совместно используемая память доступна из различных процессов, такие операции, как создание, поиск и уничтожение объектов, автоматически синхронизируются. Если две программы пытаются создавать объекты с разными именами в управляемой совместно используемой памяти, доступ сериализуется соответствующим образом. Для выполнения нескольких операций в одно время, не прерываясь операциями из другого процесса, используйте функцию член `atomic_func()` ([пример 33.11](#Пример-3311-Атомарныйный-доступ-на-управляемой-совместно-используемой-памяти)).


#### Пример 33.11. Атомарныйный доступ на управляемой совместно используемой памяти
```c++
#include <boost/interprocess/managed_shared_memory.hpp>
#include <functional>
#include <iostream>

using namespace boost::interprocess;

void construct_objects(managed_shared_memory &managed_shm)
{
  managed_shm.construct<int>("Integer")(99);
  managed_shm.construct<float>("Float")(3.14);
}

int main()
{
  shared_memory_object::remove("Boost");
  managed_shared_memory managed_shm{open_or_create, "Boost", 1024};
  auto atomic_construct = std::bind(construct_objects,
    std::ref(managed_shm));
  managed_shm.atomic_func(atomic_construct);
  std::cout << *managed_shm.find<int>("Integer").first << '\n';
  std::cout << *managed_shm.find<float>("Float").first << '\n';
}
```
`atomic_func()` ожидает, что в качестве единственного параметра функцию, которая не принимает никаких параметров и не имеет возвращаемого значения. Передаваемая функция будет вызываться таким образом, что обеспечивается исключительный доступ к управляемой совместно используемой памяти. Тем не менее, исключительный доступ обеспечивается только тогда, когда все другие процессы, которые имеют доступ к управляемой совместно используемой памяти, также используют `atomic_func()`. Если другой процесс имеет указатель на объект в управляемой совместно используемой памяти, он может получить доступ к объекту и изменять его, используя свой указатель.

Boost.Interprocess также может быть использован для синхронизации доступа к объектам. Так как Boost.Interprocess не знает, кто может получить доступ к отдельным объектам в конкретный момент времени, синхронизация должна быть явно обработана. В следующем разделе представлены классы, предусмотренные для синхронизации.



