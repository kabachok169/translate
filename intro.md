# Глава 33. Boost.Interprocess #

Содержание:

[Совместно-используемая память](#Совместно-используемая-память)  
[Управление совместно-используемой памятью]()  
Синхронизация

Interprocess-связи описывают механизмы для обмена данными между программами, работающими на одном и том же компьютере. Это не 
включает в себя сетевую связь. Для обмена данными между программами, работающими на разных компьютерах, подключенных через сеть, 
смотрите [Главу 32](https://theboostcpplibraries.com/boost.asio "Глава 32. Boost.Asio"), которая описывает Boost.Asio.

В этой главе представлена библиотека [Boost.Interprocess](http://www.boost.org/doc/libs/1_62_0/doc/html/interprocess.html), которая содержит многочисленные классы(, абстрактные)? специальные интерфейсы
операционной системы для межпоцессного взаимодействия. Даже несмотря на то, что концепции межпроцессного взаимодействия одинаковы 
между разными операционными системами, интерфейсы могут сильно различаться. Boost.Interprocess обеспечивает независимый от платформы доступ.

В то время, как Boost.Asio может использоваться для обмена данными между процессами, проходящими на одном компьютере, Boost.Interprocess 
обычно обеспечивает более высокую производительность. Boost.Interprocess-вызовы функций операционной системы оптимизированы для обмена данными между процессами, проходящими на одном компьютере, и, таким образом, должен быть лучшим выбором для обмена данными без сети.

# Совместно-используемая память #

Общая память, как правило, самая быстрая форма межпроцессного взаимодействия. Под этим понятием подразумевается область памяти, которая разделяется между процессами. Один процесс может записывать данные в этой области, а другой процесс может читать его.

В Boost.Interprocess класс `boost::interprocess::shared_memory_object` используется для представления общей памяти. Чтобы использовать этот класс необходимо подключить заголовочный файл `boost/interprocess/shared_memory_object.hpp`.

#### Пример 33.1. Создание общей памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  std::cout << shdmem.get_name() << '\n';
  offset_t size;
  if (shdmem.get_size(size))
    std::cout << size << '\n';
}
```


Конструктор `boost::interprocess::shared_memory_object` принимает три параметра. Первый параметр определяет открытие или создание общей памяти. [Пример 33.1](#Пример-331-Создание-общей-памяти) 
обрабатывает оба варианта: `boost::interprocess::open_or_create` откроет общую память, если она уже существует или создаст ее в обратном  случае. 

Открытие существующей совместной памяти предполагает, что она была создана ранее. Для того, чтобы однозначно определить совместно-используемую  память, ей присваивается имя, которое передается вторым параметром в конструктор `boost::interprocess::shared_memory_object`.

Третий параметр определяет, каким образом процесс может получить доступ к памяти. В [Примере 33.1](#Пример-331-Создание-общей-памяти) 
`boost::interprocess::read_write` показывает, что процесс имеет доступ к чтению и записи.

После создания объекта типа `boost::interprocess::shared_memory_object` соответствующий общий блок памяти будет существовать внутри операционной системы. Изначально размер этой памяти 0. Чтобы использовать эту область, вызовите `truncate()`, передав размер памяти в байтах. В [Примере 33.1](#Пример-331-Создание-общей-памяти) общая память обеспечивает пространство 1024 байта. `truncate()` может быть вызвана только в том случае, если совместная память была открыта с использованием `boost::interprocess::read_write`. В ином случае выбросится исключение с типом `boost::interprocess::interprocess_exception is thrown`. `truncate()` можно вызывать несколько раз, чтобы регулировать размер выделенной памяти.

После создания общей памяти, могут быть вызваны функции-члены, такие как `get_name()` и `get_size()`, для запроса имени или размера этой памяти.

Поскольку совместная память используется для обмена информацией между разными процессами, каждый из них должен отобразить? общую память в свое адресное пространство. Для этого используется класс `boost::interprocess::mapped_region`. Неожиданностью может оказаться то, что для доступа к совместной памяти понадобятся два класса (`boost::interprocess::shared_memory_object` и `boost::interprocess::mapped_region`). Это сделано для того, чтобы класс `boost::interprocess::mapped_region` мог также быть использован для отображения других объектов в адресное пространство процесса.

#### Пример 33.2. Отображение общей памяти в адресное пространство процесса
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  mapped_region region{shdmem, read_write};
  std::cout << std::hex << region.get_address() << '\n';
  std::cout << std::dec << region.get_size() << '\n';
  mapped_region region2{shdmem, read_only};
  std::cout << std::hex << region2.get_address() << '\n';
  std::cout << std::dec << region2.get_size() << '\n';
}
```


Для использования класса `boost::interprocess::mapped_region` необъходимо подключить заголовочный файл `boost/interprocess/mapped_region.hpp`. В качестве первого параметра конструктора `boost::interprocess::mapped_region` должен быть передан объект типа  `boost::interprocess::shared_memory_object` Второй параметр определяет степень доступа к памяти(read-only или read-write).

В [Примере 33.2](#Пример-332-Отображение-общей-памяти-в-адресное-пространство-процесса) создает два объекта типа `boost::interprocess::mapped_region`. Общая память с именем Boost отображается дважды в адресное пространство процесса. Адрес и размер отображенной области памяти записывается в стандартный поток вывода с помощью функций-членов `get_address()` и `get_size()`. `get_size()` возвращает 1024 в обоих случаях, но возвращаемое значение `get_address()` отличается для каждого объекта.

####Note

[Пример 33.2](#Пример-332-Отображение-общей-памяти-в-адресное-пространство-процесса) и еще несколько примеров, приведенных ниже вызовут ошибку при компиляции в  Visual C++ 2013 и Boost 1.55.0(исправлена в Boost 1.56.0). Этот баг описан в [тикете 9332](https://svn.boost.org/trac/boost/ticket/9332).

#### Пример 33.3. Запись и чтение числа в общей памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  shared_memory_object shdmem{open_or_create, "Boost", read_write};
  shdmem.truncate(1024);
  mapped_region region{shdmem, read_write};
  int *i1 = static_cast<int*>(region.get_address());
  *i1 = 99;
  mapped_region region2{shdmem, read_only};
  int *i2 = static_cast<int*>(region2.get_address());
  std::cout << *i2 << '\n';
}
```
В [Примере 33.3](#Пример-333-Запись-и-чтение-числа-в-общей-памяти) используется отображенная область памяти для записи и чтения числа.  ***region*** записывает число `99` в начало области. ***region2*** читает соответствующее место в этой области и записывает число в стандартный поток вывода. Несмотря на то, что ***region*** и ***region2*** представляют различные области памяти в процессе, как видно в возвращаемом значении `get_address()` в предыдущем примере, программа напечатает `99`, поскольку обе области памяти имеют доступ к одной основной совместной памяти.

#### Пример 33.4. Удаление совместно-используемой памяти
```c++
#include <boost/interprocess/shared_memory_object.hpp>
#include <iostream>

using namespace boost::interprocess;

int main()
{
  bool removed = shared_memory_object::remove("Boost");
  std::cout << std::boolalpha << removed << '\n';
}
```
Для удаления общей памяти, в `boost::interprocess::shared_memory_object` есть функция-член `remove()`, принимающая имя этой памяти в качестве параметра(см. [Пример 33.4](#Пример-334-Удаление-совместно-используемой-памяти)).

